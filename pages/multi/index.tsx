import type { NextPage } from 'next'
import Head from 'next/head'
import { useState } from 'react'
import { prisma } from '../../lib/prisma'
import { GetServerSideProps } from 'next'
import { useRouter } from 'next/router'
import { useForm } from './hook'; 



interface FormData {
  name:string
  idp:string
  quantity:string
  description:string
  id:string
}

// Array interface
interface Parts {
  parts: {
  id:string
  name:string
  idp:string
  quantity:string
  description:string
  }[]
}

// Load Parts from getServerSideProps server side rendering
const Home: NextPage<Parts> = ({ parts }) => {
  const { step, form, setForm, nextStep, prevStep, resetForm } = useForm();
  const [newPart, setNewPart] = useState<Boolean>(true);
  const router = useRouter();

  const refreshData = () => {
    router.replace(router.asPath)
  }

  async function handleSubmit(data: FormData) {
    try {
      if (newPart) {
        if (data.name && data.idp) {
          // CREATE
          fetch('api/create', {
            body: JSON.stringify(data),
            headers: {
              'Content-Type': 'application/json'
            },
            method: 'POST'
          }).then(() => {
            setForm({name:'', idp:'', quantity:'', description:'',id:''});
            refreshData();
            router.push('/dashboard'); // Redirect to the dashboard page
          });
        } else {
          alert("Part Name and ID can not be blank");
        }
      } else {
        // UPDATE
        fetch(`api/part/${data.id}`, {
          body: JSON.stringify(data),
          headers: {
            'Content-Type': 'application/json',
          },
          method: 'PUT'
        }).then(() => {
          setForm({ name: '', idp: '', quantity: '', description: '',id:''});
          setNewPart(true);
          refreshData();
          router.push('/dashboard'); // Redirect to the dashboard page
        });
      }
    } catch (error) {
      console.log(error);
    }
  }
  

  async function updatePart(
    name: string,
    idp: string,
    quantity: string,
    description: string,
    id: string
  ) {
    console.log("updatePart called"); // Add this line
    setForm({ name, idp, quantity, description, id });
    setNewPart(false);
  }
  

  async function deletePart(id: string) {
    try {
      fetch(`api/part/${id}`, {
        headers: {
          'Content-Type': 'application/json',
        },
        method: 'DELETE'
      }).then(() => {
        refreshData()
      })
    } catch (error) {
      console.log(error)
    }    
  }

  function handleCancel() {
    setForm({name:'', idp:'', quantity:'', description:'', id:''})
    setNewPart(true)
  }

  return (
    <div className=''>
      <Head>
        <title>Parts</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      
      <h1 className="text-center font-bold text-2xl m-4">Parts</h1>
      {step === 1 && (
        <form
          className="w-auto min-w-[25%] max-w-min mx-auto space-y-6 flex flex-col items-stretch"
          onSubmit={e => {
            e.preventDefault();
            if (form.name && form.idp) {
              // Proceed with the submission
              
              nextStep();
            } else {
              // Show an alert message if inputs are missing
              alert("Please fill in Part Name and Part ID fields.");
            }
          }}
        >
          <div className="field field_v1">
            <label htmlFor="name" className="w-1 h-1 p-0 border-0 absolute clip w-[1px] h-[1px] overflow-hidden">Part Name</label>
            <input type="text" 
              placeholder="Enter Part Name" 
              value={form.name} 
              onChange={e => setForm({...form, name: e.target.value})}
              className="field__input"
            />
            <span className="absolute inset-0 pointer-events-none cursor-text field__label-wrap">
              <span className="field__label">Part Name</span>
            </span>
          </div>
      
        <input type="text" placeholder="Part ID" 
          value={form.idp} 
          onChange={e => setForm({...form, idp: e.target.value})} 
          className="border-2 rounded border-gray-600 p-1"
        />

        <button type="submit" className="bg-blue-500 text-white rounded p-1">
            Next
        </button>
        </form>
      )}

{step === 2 && (
  <form
    className="w-auto min-w-[25%] max-w-min mx-auto space-y-6 flex flex-col items-stretch"
    onSubmit={e => {
      e.preventDefault();
      if (form.quantity && form.description) {
        // Proceed with the submission
        handleSubmit(form); // This handles both create and update
        nextStep();
      } else {
        // Show an alert message if inputs are missing
        alert("Please fill in Quantity and Description fields.");
      }
    }}
  >
    <input
      type="number"
      placeholder="Quantity"
      value={form.quantity}
      onChange={e => setForm({ ...form, quantity: e.target.value })}
      className="border-2 rounded border-gray-600 p-1"
    />
    <textarea
      placeholder="Description"
      value={form.description}
      onChange={e => setForm({ ...form, description: e.target.value })}
      className="border-2 rounded border-gray-600 p-1"
    />
    <button
      type="submit"
      className="bg-blue-500 text-white rounded p-1"
    >
      Submit
    </button>
    <button
      type="button"
      onClick={prevStep}
      className="bg-gray-400 text-white rounded p-1"
    >
      Back
    </button>
  </form>
)}
    </div>
  );
}

export default Home

export const getServerSideProps: GetServerSideProps = async () => {
  // READ all Parts from DB
  const parts = await prisma?.part.findMany({
    select: {
      name: true,
      idp: true,
      id: true,
      quantity: true,
      description: true,
    }
  });

  return {
    props: {
      parts: parts || [], // Ensure that parts is initialized even if it's null
    }
  };
};
